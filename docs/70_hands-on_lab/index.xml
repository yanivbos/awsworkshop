<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hands-On Lab on JFrog Workshop</title>
    <link>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab.html</link>
    <description>Recent content in Hands-On Lab on JFrog Workshop</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language><atom:link href="https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fork the Lab Repository</title>
      <link>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/1_fork_lab_repo.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/1_fork_lab_repo.html</guid>
      <description>To get started, you will need to fork this workshop repository. It contains the files, scripts and configurations that are required to complete the hands-on lab.
 Navigate to https://github.com/jefferyfry/awsworkshop. In the top-right corner of the GitHub repository page, click Fork. Wait for GitHub to complete the forking process. In your Cloud9 terminal, clone the new fork to your local git directory.
$ git clone https://github.com/[username]/awsworkshop.git  In the next sections, you will make changes to your new repository.</description>
    </item>
    
    <item>
      <title>Configure the GitHub Integration</title>
      <link>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/10_configure_github_integration.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/10_configure_github_integration.html</guid>
      <description>In order for JFrog Pipelines to get access to the code in your awsworkshop repository, we must first set up a Pipelines GitHub integration. This allows Pipelines to authenticate and get access to your GitHub repositories. To do this, we create a GitHub Personal Access Token with the correct permissions.
JFrog Pipelines can also integrate with other source code repositories such as GitHub Enterprise, BitBucket and GitLab.   Go to your GitHub Personal Access Tokens settings page.</description>
    </item>
    
    <item>
      <title>Configure the Artifactory Integration</title>
      <link>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/20_configure_artifactory_integration.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/20_configure_artifactory_integration.html</guid>
      <description>Similar to the GitHub Integration, in the following steps you will configure an Artifactory Integration that allows JFrog Pipelines to also access your Artifactory repositories in order to publish your artifacts and build info. You will do this by creating an API key.
Artifactory offers a universal solution supporting all major package formats including Alpine, Maven, Gradle, Docker, Conda, Conan, Debian, Go, Helm, Vagrant, YUM, P2, Ivy, NuGet, PHP, NPM, RubyGems, PyPI, Bower, CocoaPods, GitLFS, Opkg, SBT and more.</description>
    </item>
    
    <item>
      <title>Configure the Initialization Pipeline</title>
      <link>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/30_configure_initialization_pipeline.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/30_configure_initialization_pipeline.html</guid>
      <description>Next, we will update the lab pipelines to add your new GitHub and Artifactory integrations. In previous steps, you [forked and cloned the lab repository.]() We will modify the initialization pipeline in your forked Hoare repository to add these integrations.
 In your local git directory, open awsworkshop/jfrog_pipelines/init-jfrog.yml in an editor. Update the resources section of the file to use your new forked repository. Change the path to use your username.</description>
    </item>
    
    <item>
      <title>Configure the Pipeline Source</title>
      <link>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/40_configure_pipeline_source.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/40_configure_pipeline_source.html</guid>
      <description>In these next steps, we will add the build pipelines as a JFrog Pipelines source. This will allow JFrog Pipelines to execute these pipelines automatically whenever there is a commit or manually as needed.
A Pipeline Source represents a source control repository (such as GitHub or BitBucket) where Pipelines definition files can be found. A pipeline source connects to the repository through an integration.   In your JFrog Platform instance, go to Pipelines â–º Pipeline Sources.</description>
    </item>
    
    <item>
      <title>Execute the Initialization Pipeline</title>
      <link>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/50_execute_initialization_pipeline.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/50_execute_initialization_pipeline.html</guid>
      <description>The first pipeline that we will execute will initialize our environment. This pipeline will create users, groups, permissions, repositories, Xray policies and watches, Xray indexes and access federation. This prepares our JFrog Platform instance to run our gradle and npm build pipelines.
This pipeline initializes the JFrog Platform for the next build pipelines by creating the necessary users, repositories, permissions and Xray configuration. It does this by using the JFrog Platform REST APIs.</description>
    </item>
    
    <item>
      <title>Execute the NPM Build Pipeline</title>
      <link>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/70_execute_npm_build_pipeline.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/70_execute_npm_build_pipeline.html</guid>
      <description>The npm_build pipeline builds our web application. This pipeline uses a NpmBuild native Pipelines step build the user interface components. Next, it uses NpmPublish to publish the components. DockerBuild and DockerPush native steps are used to build a Docker image and push it to Artifactory. It then scans the build using the XrayScan native step. Then it pushes the produced artifacts to the &amp;ldquo;staging&amp;rdquo; repository in Artifactory along with all build information by using the PromoteBuild native step.</description>
    </item>
    
    <item>
      <title>Configure ECS Permissions</title>
      <link>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/80_configure_ecs_permissions.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/80_configure_ecs_permissions.html</guid>
      <description>In the previous section, we set up JFrog Pipelines to authenticate and publish images to Artifactory. In this section, we will add the same credentials to AWS Secrets Manager and create an ECS IAM role. This will allow Amazon ECS to pull the image from Artifactory and deploy it.
Private registry authentication for ECS tasks using AWS Secrets Manager enables you to store your credentials securely and then reference them in your container definition.</description>
    </item>
    
    <item>
      <title>Deploy Your NPM Image with ECS</title>
      <link>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/90_deploy_your_image.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/90_deploy_your_image.html</guid>
      <description>We are now ready to deploy your image with Amazon ECS.
Private registry authentication for ECS tasks using AWS Secrets Manager enables you to store your credentials securely and then reference them in your container definition. This allows your ECS tasks to use images from private repositories.   Go to the Amazon ECS console first-run wizard. In the Container definition section, click Configure on the custom option. For the container name, specify npm-app.</description>
    </item>
    
    <item>
      <title>Conclusion</title>
      <link>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/100_conclusion.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jefferyfry.github.io/awsworkshop/70_hands-on_lab/100_conclusion.html</guid>
      <description>In this workshop, we demonstrated that using the JFrog Platform to create CI/CD pipelines to build an application, manage the artifacts, scan the artifacts for security vulnerabilities and license compliance, and publish the artifacts of your application to a staging repository. Then you used Amazon ECS to deploy your application so that end-users can access it. Now you have a basic understanding of the JFrog Platform as a modern DevOps cloud platform on AWS.</description>
    </item>
    
  </channel>
</rss>
